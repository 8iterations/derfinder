[derfinder2](https://github.com/lcolladotor/derfinder2) basic results exploration
=================================================================================

Project: `r project`.

# Introduction

This report is meant to help explore the results of the `derfinder2` `r mycitep(bib[["derfinder2"]])` package. While the report is rich, it is meant to just start the exploration of the results and exemplify some of the code used to do so. You will most likely need a more in-depth analysis for your specific data set.

Most plots are made with using `ggplot2` `r mycitep(bib[["ggplot2"]])`.

## Code setup

```{r setup}
## For ggplot
tmp <- fullRegions
names(tmp) <- seq_len(length(tmp))
regions.df <- as.data.frame(tmp)
regions.df$width <- width(fullRegions)
rm(tmp)
nulls.df <- as.data.frame(fullNullSummary)

## Get chr lengths
if(hg19) {
	data(hg19Ideogram, package = "biovizBase")
	seqlengths(fullRegions) <- seqlengths(hg19Ideogram)[names(seqlengths(fullRegions))]
}

## Find which chrs are present in the data set
chrs <- levels(seqnames(fullRegions))
names(chrs) <- gsub("chr", "", chrs)
```


# Quality checks

## P-values

Theoretically, the p-values should be uniformly distributed between 0 and 1.

```{r pvals, fig.width=10, fig.height=10, dev=device, eval=nullExist, echo=nullExist}
p1 <- ggplot(regions.df, aes(x=pvalues, colour=seqnames)) + geom_line(stat="density") + xlim(0, 1) + labs(title="Density of p-values") + xlab("p-values") + scale_colour_discrete(limits=chrs) + theme(legend.title=element_blank())
p1
```

```{r summPval, eval=nullExist, echo=nullExist}
## Compare the pvalues
summary(fullRegions$pvalues)
```

This is the numerical summary of the distribution of the p-values. `r ifelse(nullExist, "", "Skipped because there are no null regions.")`

## Q-values

```{r summQval, eval=nullExist, echo=nullExist}
summary(fullRegions$qvalues)
```

This is the numerical summary of the distribution of the q-values. `r ifelse(nullExist, "", "Skipped because there are no null regions.")`

```{r qsummary, eval=nullExist, echo=nullExist, results="asis"}
qtable <- lapply(c(1e-04, 0.001, 0.01, 0.025, 0.05, 0.1, 1), function(x) {
	data.frame("Cut" = x, "Count" = sum(fullRegions$qvalues < x))
})
qtable <- do.call(rbind, qtable)
print(xtable(qtable, digits=4, align=rep("c", 3)), type="html", include.rownames=FALSE)
```

This table shows the number of candidate regions with q-value less than commonly used cutoff values. `r ifelse(nullExist, "", "Skipped because there are no null regions.")`

## Region width

```{r regLen, fig.width=14, fig.height=14, dev=device, eval=hasSig, echo=hasSig}
xrange <- range(log10(regions.df$width))
p2a <- ggplot(regions.df, aes(x=log10(width), colour=seqnames)) + geom_line(stat="density") + labs(title="Density of region lengths") + xlab("Region width (log10)") + scale_colour_discrete(limits=chrs) + xlim(xrange) + theme(legend.title=element_blank())
p2b <- ggplot(regions.df[idx.sig, ], aes(x=log10(width), colour=seqnames)) + geom_line(stat="density") + labs(title="Density of region lengths (significant only)") + xlab("Region width (log10)") + scale_colour_discrete(limits=chrs) + xlim(xrange) + theme(legend.title=element_blank())
grid.arrange(p2a, p2b)
```

```{r regLen2, fig.width=10, fig.height=10, dev=device, eval=!hasSig, echo=!hasSig}
p2a <- ggplot(regions.df, aes(x=log10(width), colour=seqnames)) + geom_line(stat="density") + labs(title="Density of region lengths") + xlab("Region width (log10)") + scale_colour_discrete(limits=chrs) + theme(legend.title=element_blank())
p2a
```

This plot shows the density of the region lengths for all regions. `r ifelse(hasSig, "The bottom panel is restricted to significant regions (q-value < 0.1)", "")`

## Region Area

```{r regArea, fig.width=14, fig.height=14, dev=device, eval=hasSig, echo=hasSig}
xrange <- range(log10(regions.df$area))
p3a <- ggplot(regions.df, aes(x=log10(area), colour=seqnames)) + geom_line(stat="density") + labs(title="Density of region areas") + xlab("Region area (log10)") + scale_colour_discrete(limits=chrs) + xlim(xrange) + theme(legend.title=element_blank())
p3b <- ggplot(regions.df[idx.sig, ], aes(x=log10(area), colour=seqnames)) + geom_line(stat="density") + labs(title="Density of region areas (significant only)") + xlab("Region area (log10)") + scale_colour_discrete(limits=chrs) + xlim(xrange) + theme(legend.title=element_blank())
grid.arrange(p3a, p3b)
```

```{r regArea2, fig.width=10, fig.height=10, dev=device, eval=!hasSig, echo=!hasSig}
p3a <- ggplot(regions.df, aes(x=log10(area), colour=seqnames)) + geom_line(stat="density") + labs(title="Density of region areas") + xlab("Region area (log10)") + scale_colour_discrete(limits=chrs) + theme(legend.title=element_blank())
p3a
```

This plot shows the density of the region areas for all regions. `r ifelse(hasSig, "The bottom panel is restricted to significant regions (q-value < 0.1)", "")`

## Null regions: width and area

```{r nullLengthArea, fig.width=14, fig.height=14, dev=device, eval=nullExist, echo=nullExist}
p4 <- ggplot(nulls.df, aes(x=log10(width), colour=chr)) + geom_line(stat="density") + labs(title="Density of null region lengths") + xlab("Region width (log10)") + scale_colour_discrete(limits=chrs) + theme(legend.title=element_blank())
p5 <- ggplot(nulls.df, aes(x=log10(area), colour=chr)) + geom_line(stat="density") + labs(title="Density of null region areas") + xlab("Region area (log10)") + scale_colour_discrete(limits=chrs) + theme(legend.title=element_blank())
grid.arrange(p4, p5)
```

This plot shows the density of the null region lengths and areas. `r ifelse(nullExist, "", "Skipped because there are no null regions.")`

## Mean coverage

```{r meanCov, fig.width=14, fig.height=14, dev=device, eval=hasSig, echo=hasSig}
xrange <- range(log2(regions.df$meanCoverage))
p6a <- ggplot(regions.df, aes(x=log2(meanCoverage), colour=seqnames)) + geom_line(stat="density") + labs(title="Density of region mean coverage") + xlab("Region mean coverage (log2)") + scale_colour_discrete(limits=chrs) + xlim(xrange) + theme(legend.title=element_blank())
p6b <- ggplot(regions.df[idx.sig, ], aes(x=log2(meanCoverage), colour=seqnames)) + geom_line(stat="density") + labs(title="Density of region mean coverage (significant only)") + xlab("Region mean coverage (log2)") + scale_colour_discrete(limits=chrs) + xlim(xrange) + theme(legend.title=element_blank())
grid.arrange(p6a, p6b)
```

```{r meanCov2, fig.width=10, fig.height=10, dev=device, eval=!hasSig, echo=!hasSig}
p6a <- ggplot(regions.df, aes(x=log2(meanCoverage), colour=seqnames)) + geom_line(stat="density") + labs(title="Density of region mean coverage") + xlab("Region mean coverage (log2)") + scale_colour_discrete(limits=chrs) + theme(legend.title=element_blank())
p6a
```

This plot shows the density of the region mean coverage for all regions. `r ifelse(hasSig, "The bottom panel is restricted to significant regions (q-value < 0.1)", "")`


## Mean coverage vs area

```{r meanCovArea, fig.width=14, fig.height=14, dev=device, eval=hasSig, echo=hasSig}
xrange <- range(log2(regions.df$meanCoverage))
p7a <- ggplot(regions.df, aes(x=log2(meanCoverage), y=log10(area), colour=seqnames)) + geom_point() + labs(title="Region mean coverage vs area") + xlab("Region mean coverage (log2)") + ylab("Region area (log10)") + scale_colour_discrete(limits=chrs) + xlim(xrange) + theme(legend.title=element_blank())
p7b <- ggplot(regions.df[idx.sig, ], aes(x=log2(meanCoverage), y=log10(area), colour=seqnames)) + geom_point() + labs(title="Region mean coverage vs area (significant only)") + xlab("Region mean coverage (log2)") + ylab("Region area (log10)") + scale_colour_discrete(limits=chrs) + xlim(xrange) + theme(legend.title=element_blank())
grid.arrange(p7a, p7b)
```

```{r meanCovArea2, fig.width=10, fig.height=10, dev=device, eval=!hasSig, echo=!hasSig}
p7a <- ggplot(regions.df, aes(x=log2(meanCoverage), y=log10(area), colour=seqnames)) + geom_point() + labs(title="Region mean coverage vs area") + xlab("Region mean coverage (log2)") + ylab("Region area (log10)") + scale_colour_discrete(limits=chrs) + theme(legend.title=element_blank())
p7a
```

This plot shows the relationship between the region mean coverage and the area for all regions. `r ifelse(hasSig, "The bottom panel is restricted to significant regions (q-value < 0.1)", "")`

# Genomic overview

The following plots were made using `ggbio` `r mycitep(bib[["ggbio"]])` which in turn uses `ggplot2` `r mycitep(bib[["ggplot2"]])`. For more details check `plotOverview` in `derfinder2` `r mycitep(bib[["derfinder2"]])`.

## Q-values

```{r genomeOverview1, message=FALSE, fig.width=7, fig.height=9, dev=device, dpi=300, eval=nullExist, echo=nullExist}
plotOverview(regions=fullRegions, type="qval", base_size=30, areaRel=10, legend.position=c(0.97, 0.12))
```

This plot shows the genomic locations of the __candidate__ regions found in the analysis. The significant regions (by default q-value less than 0.10) are highlighted and the area of the regions is shown on top of each chromosome. Note that the area is in a relative scale.


## Annotation

```{r genomeOverview2, message=FALSE, fig.width=7, fig.height=9, dev=device, dpi=300}
plotOverview(regions=fullRegions, annotation=fullRegions, type="annotation", base_size=30, areaRel=10, legend.position=c(0.97, 0.12))
```

This genomic overview plot shows the annotation region type for the __candidate__ regions. Note that the regions are shown only if the annotation information is available. Below is a table of the actual number of results per annotation region type.

```{r annoReg, results="asis"}
annoReg <- table(fullRegions$region, useNA="always")
annoReg.df <- data.frame(Region=names(annoReg), Count=as.vector(annoReg))
print(xtable(annoReg.df, align=rep("c", 3)), type="html", include.rownames=FALSE)
```

## Annotation (significant)

```{r genomeOverview3, message=FALSE, fig.width=7, fig.height=9, dev=device, dpi=300, eval=hasSig, echo=hasSig}
plotOverview(regions=fullRegions[idx.sig], annotation=fullRegions[idx.sig], type="annotation", base_size=30, areaRel=10, legend.position=c(0.97, 0.12))
```

This genomic overview plot shows the annotation region type for the __candidate__ regions that have a q-value less than 0.10 (default setting). Note that the regions are shown only if the annotation information is available. `r ifelse(hasSig, "", "Plot skipped because there are no significant regions.")`


# Best regions

The following plots were made using `ggbio` `r mycitep(bib[["ggbio"]])` which in turn uses `ggplot2` `r mycitep(bib[["ggplot2"]])`. For more details check `plotRegion` in `derfinder2` `r mycitep(bib[["derfinder2"]])`. The dynamic table in this section is generated using `rCharts` `r mycitep(bib[["rCharts"]])`.

## Plots

```{r plotGenome, message=FALSE, eval=makeBestPlots, echo=makeBestPlots}
## Select best by area
bestArea <- head(order(fullRegions$area, decreasing=TRUE), nBest)

## Graphical setup: ideograms 
if(hg19 & is.null(p.ideos)) {
	ideos.set <- as.character(unique(seqnames(fullRegions[bestArea])))
	p.ideos <- lapply(ideos.set, function(xx) { 
		plotIdeogram(genome = "hg19", subchr=xx)
	})
	names(p.ideos) <- ideos.set
} else {
	stopifnot(!is.null(p.ideos))
}

## Graphical setup: transcription database
if(hg19 & is.null(txdb)) {
	txdb <- TxDb.Hsapiens.UCSC.hg19.knownGene
} else {
	stopifnot(!is.null(txdb))
}

## Graphical setup: main plotting function
regionPlot <- function(idx, tUse="pval") {
	## Chr specific selections
	chr <- as.character(seqnames(fullRegions[idx]))
	chrnum <- gsub("chr", "", chr)
	p.ideo <- p.ideos[[chr]]
	covInfo <- fullCov[[chrnum]]
	
	## Make the plot
	p <- plotRegion(idx, regions=fullRegions, annotation=regions.df, coverageInfo=covInfo, groupInfo=optionsStats$groupInfo, titleUse=tUse, txdb=txdb, p.ideogram=p.ideo)
	print(p)
	rm(p.ideo, covInfo)
	
	return(invisible(TRUE))	
}
```


`r ifelse(makeBestPlots, paste("Below are the best", nBest, "regions ordered by area."), "No plots were generated as requested.")`
 

```{r bestArea, message=FALSE, fig.width=11, fig.height=13, dev=device, eval=makeBestPlots, echo=makeBestPlots}

## Genome plots
for(idx in bestArea) {
	regionPlot(idx, ifelse(nullExist, "pval", "none"))
}
```

## Region information

Below is an interactive table with the top 100 regions ranked by area.

<link rel="stylesheet" href="http://ajax.aspnetcdn.com/ajax/jquery.dataTables/1.9.4/css/jquery.dataTables.css" />
<script src="http://ajax.aspnetcdn.com/ajax/jquery.dataTables/1.9.4/jquery.dataTables.min.js"></script>

```{r bestAreaInfo, results="asis"}
topArea <- head(regions.df, 100)
topArea <- data.frame("areaRank"=order(topArea$area, decreasing=TRUE), topArea)
d <- data.table(topArea)
t1 <- dTable(d, sPaginationType=  'full_numbers', iDisplayLength=10, sScrollX='100%')
t1$print("regions", cdn=TRUE)
```

# Permutations

Below is the information on how the samples were permutted. 

## Summary

```{r permute2, eval=usedPermutations, echo=usedPermutations}
## Get the permutation information
nSamples <- seq_len(length(optionsStats$groupInfo))
permuteInfo <- lapply(seeds, function(x) {
	set.seed(x)
	idx <- sample(nSamples)
	data.frame(optionsStats$groupInfo[idx])
})
permuteInfo <- cbind(data.frame(optionsStats$groupInfo), do.call(cbind, permuteInfo))
colnames(permuteInfo) <- c("original", paste0("perm", 1:10))
## The raw information
# permuteInfo

n <- names(table(permuteInfo[, 2]))
permuteDetail <- data.frame(matrix(NA, nrow=10*length(n), ncol = 2 + length(n)))
permuteDetail[, 1] <- rep(1:10, each=length(n))
permuteDetail[, 2] <- rep(n, 10)
colnames(permuteDetail) <- c("permutation", "group", as.character(n))
l <- 1
m <- 3:ncol(permuteDetail)
for(j in n) {
	k <- which(permuteInfo[, 1] == j)
	for(i in 2:11) {
		permuteDetail[l, m] <- table(permuteInfo[k, i])
		l <- l + 1
	}
}

## Print the summary
summary(permuteDetail[, m])
```

This table shows the summary per group of and can be used for fast detection of anomalies. `r ifelse(usedPermutations, "", "Skipped because no permutations were used.")`

Note that in `derfinder2` `r mycitep(bib[["derfinder2"]])` the re-sampling of the samples is done without replacement. This is done in an effort to avoid singular model matrices. While the sample balance is the same across the permutations, what changes are the adjusted variables (including the column medians).

## Interactive

The following table shows how the group labels were permuted. `r ifelse(usedPermutations, "", "Skipped because no permutations were used.")` This can be useful to detect whether a permutation in particular had too many samples of a group labeled as another group, meaning that the resulting permuted group label resulted in pretty much a name change.

```{r permuteTable, results="asis", eval=usedPermutations, echo=usedPermutations}
d2 <- data.table(permuteDetail)
t2 <- dTable(d2, sPaginationType=  'full_numbers', iDisplayLength=10, sScrollX='100%')
t2$print("permutation")
```




# Bibliography

This report is part of `derfinder2` `r mycitep(bib[["derfinder2"]])` and was generated using `knitr` `r mycitep(bib[["knitr"]])` and styled via `knitrBootstrap` `r mycitep(bib[["knitrBootstrap"]])`.

Citations made with `knitcitations` `r mycitep(bib[["knitcitations"]])`.

```{r bibliography, results='asis', echo=FALSE, cache=FALSE}
## Print bibliography
bibliography()
```

# Reproducibility

This report was generated in path `r tmpdir` using the following call:

```{r thecall, echo=FALSE}
theCall
```

Date the report was generated.

```{r reproducibility1, echo=FALSE}
## Date the report was generated
Sys.time()
```

Wallclock time spent generating the report.

```{r reproducibility2, echo=FALSE}
## Processing time in seconds
totalTime <- diff(c(startTime, Sys.time()))
round(totalTime)
```

`R` session information.

```{r reproducibility3, echo=FALSE}
## Session info
sessionInfo()
```
